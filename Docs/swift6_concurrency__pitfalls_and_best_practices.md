# Swift 6 Concurrency Updates: @MainActor, Pitfalls, and Best Practices

Swift 6 brings important updates to the concurrency model introduced in Swift 5.5, with stricter enforcement of thread-safety and new behaviors around the `@MainActor` global actor. These changes aim to eliminate data races by default and clarify how UI-related code should execute on the main thread. This report outlines the key concurrency changes in Swift 6 (especially regarding `@MainActor`), common issues and bugs developers encounter, recommended solutions and best practices, migration challenges from earlier Swift versions, and insights from developer experiences.

## 1. Key Changes in Swift 6 Concurrency (Focus on `@MainActor`)

**Stricter Concurrency Checking:** Swift 6 enables *data-race safety by default*, turning many concurrency-related compiler warnings into errors. The compiler now diagnoses more race conditions at compile time, rather than just warning about them ([Migrating to Swift 6](https://blog.brandonweng.com/posts/migrating-swift-6#:~:text=The%20most%20compelling%20reason%20to,rely%20heavily%20on%20concurrent%20operations)). In practice, operations that violate actor isolation or `Sendable` rules (which might have only produced warnings in Swift 5.x) will fail to compile under Swift 6's *strict concurrency* mode. This means calling an actor-isolated or `@MainActor` function from a non-isolated context without proper `await`/isolation is no longer allowed (a compile-time error rather than a warning) ([How to fix this Swift 6 migration … | Apple Developer Forums](https://developer.apple.com/forums/thread/763849#:~:text=Xcode%20shows%20warnings%20that%20,How%20can%20I%20fix%20this)).

**Main Actor Isolation for UI:** Apple has expanded the use of the `@MainActor` global actor to simplify UI concurrency. At WWDC 2024, a significant change was announced: the SwiftUI `View` protocol itself is now annotated with `@MainActor` ([SwiftUI Views and @MainActor](https://fatbobman.com/en/posts/swiftui-views-and-mainactor/#:~:text=,protocol%20in%20the%20Xcode%2016)). *All types conforming to `View` in Xcode 16 (Swift 6) automatically inherit main-actor isolation.* In earlier Xcode versions, only the `body` property of a view was `@MainActor`, not the entire view type ([Task Isolation Inheritance and Swi… | Apple Developer Forums](https://forums.developer.apple.com/forums/thread/761150#:~:text=In%20Xcode%2015%20and%20earlier,protocol%20was%20defined%20like%20this)) ([Task Isolation Inheritance and Swi… | Apple Developer Forums](https://forums.developer.apple.com/forums/thread/761150#:~:text=In%20contrast%2C%20in%20Xcode%2016,protocol%20looks%20ilke%20this)). With Swift 6, this change means any code in a SwiftUI view (properties, methods, initializers) is assumed to run on the main thread by default ([Task Isolation Inheritance and Swi… | Apple Developer Forums](https://forums.developer.apple.com/forums/thread/761150#:~:text=%40MainActor%20%40preconcurrency%20public%20protocol%20View,get%20%7D)). This reduces confusion around which parts of a view are main-thread-bound, but also means more of your UI code is restricted to the main actor ([Task Isolation Inheritance and Swi… | Apple Developer Forums](https://forums.developer.apple.com/forums/thread/761150#:~:text=The%20entire%20,%60View%60%20chain)).

**Global Actor Inference Changes:** Swift 6 moves toward more explicit actor isolation rules. Certain automatic *global actor inference* behaviors from Swift 5 have been dialed back or disabled in Swift 6 mode ([Change to Global Actor Inference in Swift 6 Language Mode? - Using Swift - Swift Forums](https://forums.swift.org/t/change-to-global-actor-inference-in-swift-6-language-mode/76086#:~:text=Long%20story%20short%2C%20Swift%206,such%20cases%20about%20isolation%20mismatch)). For example, subclasses or extensions may no longer implicitly inherit a global actor from their context, and code that relied on implicit main-actor inference might now require explicit `@MainActor` annotations. In short, Swift 6 is “more explicit in isolation terms” – some types that were inferred as main-actor isolated in Swift 5 might no longer be inferred, leading to isolation mismatch errors until you annotate them ([Change to Global Actor Inference in Swift 6 Language Mode? - Using Swift - Swift Forums](https://forums.swift.org/t/change-to-global-actor-inference-in-swift-6-language-mode/76086#:~:text=Long%20story%20short%2C%20Swift%206,such%20cases%20about%20isolation%20mismatch)). This encourages developers to mark concurrency requirements clearly (e.g. mark a subclass `@MainActor` if it must remain on the main thread, rather than assuming it inherits that from a superclass).

**Concurrency Model Enhancements:** Beyond `@MainActor`, Swift 6 includes language improvements to close gaps in the concurrency model. The Swift team focused on ensuring *complete data-race safety*, designing features like **isolated default values** for global/static variables, automatic inference of `@Sendable` for closures, stricter checking for global and static data, and mechanisms to safely pass non-`Sendable` data across actors ([Progress toward the Swift 6 language mode - Announcements - Swift Forums](https://forums.swift.org/t/progress-toward-the-swift-6-language-mode/68315#:~:text=%2A%20SE,values%20through%20isolated%20value%20regions)) ([Progress toward the Swift 6 language mode - Announcements - Swift Forums](https://forums.swift.org/t/progress-toward-the-swift-6-language-mode/68315#:~:text=Together%2C%20these%20changes%20fill%20the,and%20can%20be%20explored%20independently)). These changes (many introduced through Swift Evolution proposals) plug holes where race conditions could sneak in, and reduce false positives from the concurrency checker ([Progress toward the Swift 6 language mode - Announcements - Swift Forums](https://forums.swift.org/t/progress-toward-the-swift-6-language-mode/68315#:~:text=There%20are%20still%20a%20number,checking%20difficult%20to%20program%20against)) ([Progress toward the Swift 6 language mode - Announcements - Swift Forums](https://forums.swift.org/t/progress-toward-the-swift-6-language-mode/68315#:~:text=Together%2C%20these%20changes%20fill%20the,and%20can%20be%20explored%20independently)). For example, Swift 6 can infer when a closure should be `@Sendable` (thread-safe) and will enforce that, and it ensures that global or static variables accessed from an actor context are properly isolated or marked ([Progress toward the Swift 6 language mode - Announcements - Swift Forums](https://forums.swift.org/t/progress-toward-the-swift-6-language-mode/68315#:~:text=%2A%20SE,values%20through%20isolated%20value%20regions)). The net effect is a safer, more predictable concurrency model at the language level.

## 2. Common Concurrency Issues and Bugs in Swift 6

Adopting Swift’s concurrency (especially under Swift 6’s stricter rules) can surface a variety of issues. Developers frequently encounter the following problems:

- **Calling Main-Actor Code from the Wrong Context:** A very common error is calling a `@MainActor` function or property from a synchronous or background context without using `await` or being on the main actor. In Swift 5, this scenario would compile with a warning; in Swift 6 it triggers a compiler error ([How to fix this Swift 6 migration … | Apple Developer Forums](https://developer.apple.com/forums/thread/763849#:~:text=Xcode%20shows%20warnings%20that%20,How%20can%20I%20fix%20this)). For instance, invoking a UI update method (marked `@MainActor`) from inside a completion handler or an async task that is not on the main actor will fail to compile. A concrete example is using an API like `avPlayer.addPeriodicTimeObserver` and directly calling UI code inside its closure – Swift 6 will complain: “Call to main actor-isolated instance method in a synchronous nonisolated context; this is an error in Swift 6 language mode” ([How to fix this Swift 6 migration … | Apple Developer Forums](https://developer.apple.com/forums/thread/763849#:~:text=Xcode%20shows%20warnings%20that%20,How%20can%20I%20fix%20this)).

- **Unintended Thread Blocking via `Task` Inheritance:** Developers may assume that launching a new `Task` will run code in the background. However, if a `Task` is created within a `@MainActor` context, it **inherits** the main-actor isolation by default ([Task Isolation Inheritance and Swi… | Apple Developer Forums](https://forums.developer.apple.com/forums/thread/761150#:~:text=So%2C%20what%E2%80%99s%20going%20on%3F%20The,on%20the%20main%20thread)). This means the task’s code still runs on the main thread, potentially blocking the UI ([Task Isolation Inheritance and Swi… | Apple Developer Forums](https://forums.developer.apple.com/forums/thread/761150#:~:text=Folks%20look%20at%20this%20code,to%20prove%20this%20to%20yourself)) ([Task Isolation Inheritance and Swi… | Apple Developer Forums](https://forums.developer.apple.com/forums/thread/761150#:~:text=The%20compiler%20doesn%E2%80%99t%20complain%20about,run%20on%20the%20main%20thread)). This pitfall surprises many: e.g. in a `@MainActor class` or a SwiftUI view, writing `Task { doSomeCPUIntensiveWork() }` will execute on the main thread, freezing the UI ([Task Isolation Inheritance and Swi… | Apple Developer Forums](https://forums.developer.apple.com/forums/thread/761150#:~:text=Folks%20look%20at%20this%20code,to%20prove%20this%20to%20yourself)) ([Task Isolation Inheritance and Swi… | Apple Developer Forums](https://forums.developer.apple.com/forums/thread/761150#:~:text=The%20compiler%20doesn%E2%80%99t%20complain%20about,run%20on%20the%20main%20thread)). The confusion arises because the `Task` initializer doesn’t automatically spawn a background thread if called from a main-actor context. Without intervention, heavy computations inside such a task will lock up the app's interface.

- **Capture of Non-Sendable Types in Concurrency Closures:** Swift 6 enforces that data passed to concurrent closures must be `Sendable` (safe to transfer across threads). Developers often hit errors capturing `self` or other non-thread-safe types inside an async closure or task. For example, a SwiftUI `View` struct is not `Sendable` by default. If you start a `Task` or an `.task` modifier that implicitly captures `self` (the view) or a @State variable, the compiler will complain about capturing a non-Sendable type in a `@Sendable` closure ([Task Isolation Inheritance and Swi… | Apple Developer Forums](https://forums.developer.apple.com/forums/thread/761150#:~:text=func%20increment%28%29%20,)). In one scenario, moving a piece of state update code into a separate function caused a capture error because that function was no longer on the main actor ([Task Isolation Inheritance and Swi… | Apple Developer Forums](https://forums.developer.apple.com/forums/thread/761150#:~:text=func%20increment%28%29%20,)). These errors manifest as “Capture of 'X' with non-sendable type 'Y' in a `@Sendable` closure” and are a signal that something not thread-safe is being used from a concurrent context.

- **Main-Actor Restrictions on API Usage:** Swift 6’s checking can reveal that some APIs must be used on the main thread. For instance, accessing certain UIKit/SwiftUI singletons or properties that are main-thread-only now triggers errors if done off the main actor. A real example is defining a SwiftUI `EnvironmentKey` default value with `UIScreen.main.bounds.height`. In Swift 6, `UIScreen.main` is considered main-actor-bound, so referencing it in a static default (which is evaluated in a non-isolated context) causes a compile error: *“Main actor-isolated property 'main' can not be referenced from a nonisolated context.”* ([Swift 6 concurrency issue with EnvironmentKey - Stack Overflow](https://stackoverflow.com/questions/79015118/swift-6-concurrency-issue-with-environmentkey#:~:text=Now%20there%20seems%20to%20be,to%20uphold%20protocol%20conformance)). The SwiftUI pasteboard example is similar: using a `PasteButton` initializer outside of a view’s `body` (hence outside `@MainActor` context) led to a “main actor-isolated initializer in a nonisolated context” error ([SwiftUI Views and @MainActor](https://fatbobman.com/en/posts/swiftui-views-and-mainactor/#:~:text=Not%20long%20ago%2C%20in%20my,PasteButton)). These issues highlight that certain initializers or properties (often related to UI or system singletons) are now annotated with `@MainActor` and must be handled accordingly.

- **Overriding APIs Not Marked for Concurrency:** Some Cocoa classes and protocols aren’t fully adapted to Swift concurrency yet, which can result in tricky errors when overriding them. A case in point is subclassing `NSTextAttachmentViewProvider` and overriding `loadView()`. Developers encountered a compiler error: *“Call to main actor-isolated initializer 'init()' in a synchronous nonisolated context”*, and adding `@MainActor` on the override was disallowed due to a mismatch with the base class ([nsattributedstring - Swift 6 concurrency issue with `NSTextAttachmentViewProvider` - Stack Overflow](https://stackoverflow.com/questions/79278413/swift-6-concurrency-issue-with-nstextattachmentviewprovider#:~:text=This%20will%20not%20compile%20with,the%20following%20error)). This is essentially a limitation in Swift’s current handling of certain Obj-C SDK APIs. The root issue is that `NSTextAttachmentViewProvider` is expected to be used on the main thread, but it isn’t annotated with `@MainActor` in the SDK, and Swift 6 can't reconcile the override's isolation ([nsattributedstring - Swift 6 concurrency issue with `NSTextAttachmentViewProvider` - Stack Overflow](https://stackoverflow.com/questions/79278413/swift-6-concurrency-issue-with-nstextattachmentviewprovider#:~:text=This%20will%20not%20compile%20with,the%20following%20error)) ([nsattributedstring - Swift 6 concurrency issue with `NSTextAttachmentViewProvider` - Stack Overflow](https://stackoverflow.com/questions/79278413/swift-6-concurrency-issue-with-nstextattachmentviewprovider#:~:text=This%20is%20currently%20just%20a,on%20this%20Swift%20Forums%20thread)). Until Apple updates these APIs or the language improves, developers must work around such issues (as discussed in the next section).

- **Confusion in SwiftUI Concurrency Contexts:** SwiftUI’s design can lead to subtle concurrency context issues. Prior to Swift 6, only the `body` was main-actor, so if developers moved code out of `body` into other view methods or properties, they could lose the main-actor context unknowingly ([Task Isolation Inheritance and Swi… | Apple Developer Forums](https://forums.developer.apple.com/forums/thread/761150#:~:text=This%20compiles%20because%20the%20task,trivial%20change%2C%20the%20compiler%20complains)) ([Task Isolation Inheritance and Swi… | Apple Developer Forums](https://forums.developer.apple.com/forums/thread/761150#:~:text=That%E2%80%99s%20because%20the%20,between%20contexts%2C%20and%20rightly%20complains)). This caused errors when updating `@State` or UI from those methods. The update in Swift 6 (making the whole view `@MainActor`) mitigates this confusion by automatically isolating view code to the main thread ([Task Isolation Inheritance and Swi… | Apple Developer Forums](https://forums.developer.apple.com/forums/thread/761150#:~:text=%40MainActor%20%40preconcurrency%20public%20protocol%20View,get%20%7D)). Nonetheless, developers still need to be careful: creating an `@MainActor` observable object and storing it in a SwiftUI view property without marking the view as `@MainActor` will trigger a warning (error in Swift 6) about a main actor-isolated property in a nonisolated context ([SwiftUI Views and @MainActor](https://fatbobman.com/en/posts/swiftui-views-and-mainactor/#:~:text=struct%20DemoView%3A%20View%20,)) ([SwiftUI Views and @MainActor](https://fatbobman.com/en/posts/swiftui-views-and-mainactor/#:~:text=This%20issue%20arises%20because%2C%20by,the%20aforementioned%20issue%20is%20resolved)). In summary, many SwiftUI concurrency issues revolve around ensuring that UI state is accessed on the main actor and understanding when SwiftUI is doing that for you versus when you must annotate it yourself.

## 3. Solutions and Best Practices for Swift 6 Concurrency

To address the issues above and write robust concurrent Swift code, developers are adopting several solutions and best practices:

- **Always confine UI work to the Main Actor:** Any code that updates UI or interacts with UIKit/SwiftUI views should run on the main thread. Use the `@MainActor` attribute to annotate functions, classes, or structs that inherently belong on the UI thread (for example, view models that update UI state, or view controller classes) ([Task Isolation Inheritance and Swi… | Apple Developer Forums](https://forums.developer.apple.com/forums/thread/761150#:~:text=In%20contrast%2C%20in%20Xcode%2016,protocol%20looks%20ilke%20this)) ([Task Isolation Inheritance and Swi… | Apple Developer Forums](https://forums.developer.apple.com/forums/thread/761150#:~:text=func%20increment%28%29%20,)). In SwiftUI, if you encounter an isolation error for a view or view modifier, consider marking the entire view struct with `@MainActor` to ensure its code executes on the main thread ([SwiftUI Views and @MainActor](https://fatbobman.com/en/posts/swiftui-views-and-mainactor/#:~:text=Some%20readers%20might%20wonder%2C%20could,fundamentally%20solve%20the%20problem)) ([SwiftUI Views and @MainActor](https://fatbobman.com/en/posts/swiftui-views-and-mainactor/#:~:text=%40MainActor%20struct%20PasteButtonDemo%3A%20View%20,...)). However, be mindful that making a whole type `@MainActor` means *all* its methods (even async ones) will run on main, which is correct for UI logic but not for heavy background tasks. For one-off UI updates, you can also use `MainActor.run { ... }` or wrap code in `Task { @MainActor in ... }` to dispatch it to the main actor as needed. The key is to never directly mutate UI state from a background task without going through the main actor (the compiler will usually stop you from doing so in Swift 6).

- **Offload Heavy Work to Background Tasks Appropriately:** To avoid blocking the UI, explicitly create background tasks for expensive operations. If you're in a `@MainActor` context and need to do a CPU-intensive job, use `Task.detached` or perform the work in a separate actor or thread. For example, instead of `Task { doHeavyWork() }` inside a main-actor object (which would inherit main thread), do `Task.detached { doHeavyWork() }` to run it concurrently off the main thread ([Task Isolation Inheritance and Swi… | Apple Developer Forums](https://forums.developer.apple.com/forums/thread/761150#:~:text=So%2C%20how%20do%20you%20prevent,the%20two%20most%20obvious%20are)). Another pattern is to mark a helper method as `nonisolated` (not tied to the actor) and call that from the task, so the task doesn’t capture the actor context ([Task Isolation Inheritance and Swi… | Apple Developer Forums](https://forums.developer.apple.com/forums/thread/761150#:~:text=func%20start%28%29%20,%7D)) ([Task Isolation Inheritance and Swi… | Apple Developer Forums](https://forums.developer.apple.com/forums/thread/761150#:~:text=nonisolated%20func%20myDoSomeCPUIntensiveWork%28%29%20async%20,)). By breaking out of the main actor intentionally, you ensure background work truly runs in the background. Always design your code so that background tasks deliver results back to the main actor (for UI updates) via `await` or callbacks on the main thread.

- **Use `MainActor.assumeIsolated` for Known Main-Thread Contexts:** Swift 6 introduces `MainActor.assumeIsolated(_:)` as a way to tell the compiler “treat this closure as running on the main actor.” This is useful when you’re calling code that the system guarantees runs on the main thread, but the compiler can’t see the actor context. A prime example is completion handlers or delegates that are always called on main (by contract or because you explicitly scheduled them on `.main` queue). Rather than spawning a new `Task` (which incurs extra overhead) inside such a callback, you can wrap the code in `MainActor.assumeIsolated`. For instance, if an AVFoundation callback provides updates on the main queue, you can do: `MainActor.assumeIsolated { self?.myMainActorIsolatedMethod() }` inside that callback ([How to fix this Swift 6 migration … | Apple Developer Forums](https://developer.apple.com/forums/thread/763849#:~:text=has%20two%20functions%3A)) ([How to fix this Swift 6 migration … | Apple Developer Forums](https://developer.apple.com/forums/thread/763849#:~:text=avPlayer,self%3F.myMainActorIsolatedMethod%28%29%20%7D)). This approach, as recommended by Apple’s engineers, tells the compiler to trust that we’re already on main and even performs a runtime check to ensure that’s true ([How to fix this Swift 6 migration … | Apple Developer Forums](https://developer.apple.com/forums/thread/763849#:~:text=Note%20how%20,which%20has%20two%20functions)) ([How to fix this Swift 6 migration … | Apple Developer Forums](https://developer.apple.com/forums/thread/763849#:~:text=avPlayer,self%3F.myMainActorIsolatedMethod%28%29%20%7D)). It avoids “frequently switching actors” while still satisfying the compiler’s safety checks. Use this sparingly and only when you’re certain the code is always executed on the main thread (misusing it could lead to runtime crashes if the thread expectation is wrong ([nsattributedstring - Swift 6 concurrency issue with `NSTextAttachmentViewProvider` - Stack Overflow](https://stackoverflow.com/questions/79278413/swift-6-concurrency-issue-with-nstextattachmentviewprovider#:~:text=Right%20now%2C%20you%20can%20work,be%20on%20the%20main%20actor)) ([nsattributedstring - Swift 6 concurrency issue with `NSTextAttachmentViewProvider` - Stack Overflow](https://stackoverflow.com/questions/79278413/swift-6-concurrency-issue-with-nstextattachmentviewprovider#:~:text=This%20will%20crash%20if%20,you%20are%20using%20TextKit%20correctly))).

- **Adopt Structured Concurrency and `Sendable` Practices:** Embrace Swift’s structured concurrency features (async/await, task groups, AsyncSequence) to manage concurrent logic rather than relying on detached threads or GCD directly. This often means refactoring callback-based code. For example, if you previously kicked off multiple asynchronous operations and returned immediately, realize that an `async` function by default runs things sequentially unless you introduce parallelism via multiple tasks or task groups ([How to plan a migration to Swift 6 – Donny Wals](https://www.donnywals.com/how-to-plan-a-migration-to-swift-6/#:~:text=func%20loadPages%28%29%20async%20throws%20,)) ([How to plan a migration to Swift 6 – Donny Wals](https://www.donnywals.com/how-to-plan-a-migration-to-swift-6/#:~:text=The%20meaning%20of%20this%20code,calls%20in%20parallel%20that%20way)). Think through the concurrency semantics: decide where you need truly parallel execution and use task groups or multiple `Task { ... }` calls appropriately, or keep things sequential if order matters. Also make your data types conform to `Sendable` when necessary. If you have a type that will be shared across threads (passed into an async closure, for instance), either restrict its usage to one actor or mark it as `Sendable` (and ensure it’s thread-safe internally). Swift 6’s compiler can infer some `Sendable` conformances and will warn you if something should be `Sendable` but isn’t ([Progress toward the Swift 6 language mode - Announcements - Swift Forums](https://forums.swift.org/t/progress-toward-the-swift-6-language-mode/68315#:~:text=,values%20through%20isolated%20value%20regions)) ([Progress toward the Swift 6 language mode - Announcements - Swift Forums](https://forums.swift.org/t/progress-toward-the-swift-6-language-mode/68315#:~:text=Together%2C%20these%20changes%20fill%20the,and%20can%20be%20explored%20independently)). Avoid using `@unchecked Sendable` unless absolutely necessary – it silences the compiler but puts the onus on you to guarantee thread safety. Best practice is to redesign the code to eliminate the need for unchecked sendable (e.g., by isolating that state to an actor, or making the type truly safe to share).

- **Architectural Patterns – Actors and Global Actors:** Take advantage of actors for state that is accessed from multiple threads. For example, if you had used singletons or global variables to share mutable state, consider turning those into an `actor` (which serializes access to its state) or marking them with a global actor like `@MainActor` if all access should be on the main thread ([Migrating to Swift 6](https://blog.brandonweng.com/posts/migrating-swift-6#:~:text=Unfortunately%2C%20I%20used%20a%20ton,and%20others%20became%20Global%20MainActors)) ([Migrating to Swift 6](https://blog.brandonweng.com/posts/migrating-swift-6#:~:text=away%20from%20Singletons%20entirely,and%20others%20became%20Global%20MainActors)). One developer noted that Swift 6’s concurrency “almost forced me to move away from Singletons entirely,” refactoring some singletons into actors and others into global-main-actor isolated objects ([Migrating to Swift 6](https://blog.brandonweng.com/posts/migrating-swift-6#:~:text=Unfortunately%2C%20I%20used%20a%20ton,and%20others%20became%20Global%20MainActors)) ([Migrating to Swift 6](https://blog.brandonweng.com/posts/migrating-swift-6#:~:text=away%20from%20Singletons%20entirely,and%20others%20became%20Global%20MainActors)). This leads to code that is easier to reason about in terms of thread access. You can also define your own global actors for specific subsystems – for instance, a `@DatabaseActor` for database operations – to funnel those tasks onto a specific thread or queue. Apple’s concurrency model allows declaring custom global actors and annotating types or functions with them for organized isolation.

- **SwiftUI Concurrency Tips:** With SwiftUI, prefer to keep your view code simple and delegate heavy work to model objects (which can be actors or use async tasks). If you use the new Observation framework or `@Observable` objects, you might mark those model classes with `@MainActor` to ensure their updates happen on the main thread ([SwiftUI Views and @MainActor](https://fatbobman.com/en/posts/swiftui-views-and-mainactor/#:~:text=This%20approach%20also%20brings%20other,MainActor)). Just be aware that if you then create an instance in a view, the view should also be main-actor, or you should instantiate the object outside the view’s nonisolated context (e.g., in the App struct or in an `.environment` injection) ([SwiftUI Views and @MainActor](https://fatbobman.com/en/posts/swiftui-views-and-mainactor/#:~:text=struct%20DemoView%3A%20View%20,)) ([SwiftUI Views and @MainActor](https://fatbobman.com/en/posts/swiftui-views-and-mainactor/#:~:text=This%20issue%20arises%20because%2C%20by,the%20aforementioned%20issue%20is%20resolved)). In cases where you have a view that *must* perform some async work, you can use the `.task` view modifier, which by default runs on the view’s actor context (now main actor by default). If the async work is not UI-sensitive, you could detach it or use an actor to handle it to avoid clogging the main thread. Another tip: when facing many “Main actor” related warnings in SwiftUI, do **not** arbitrarily add `@MainActor` to everything as a quick fix. While adding `@MainActor` to a view or function will silence the errors ([SwiftUI Views and @MainActor](https://fatbobman.com/en/posts/swiftui-views-and-mainactor/#:~:text=Some%20readers%20might%20wonder%2C%20could,fundamentally%20solve%20the%20problem)) ([SwiftUI Views and @MainActor](https://fatbobman.com/en/posts/swiftui-views-and-mainactor/#:~:text=Indeed%2C%20annotating%20the%20entire%20,button)), it might force more code than necessary onto the main thread. Apply it thoughtfully – e.g., it makes sense on a SwiftUI `View` that holds a main-actor bound model, or on methods that trigger UI changes – but you might not want an entire utility class to be main-actor if it does heavy background processing.

- **Interoperability Workarounds:** When working with older frameworks or system APIs not yet optimized for Swift concurrency, you sometimes need interim solutions:
  - Use `@preconcurrency import ModuleName` to suppress strict concurrency checks on imported Objective-C APIs that aren’t annotated for Sendability or actor isolation. This tells the compiler to be lenient with that library. (For example, if an Apple framework class isn’t marked `Sendable` but you know it’s fine, or an old delegate method is called on the main thread but not annotated, etc.)
  - Use `MainActor.assumeIsolated` (as mentioned) when overriding an API that is known to be main-thread only. In the `NSTextAttachmentViewProvider` case, the workaround was to wrap the view creation in `MainActor.assumeIsolated` within `loadView()` ([nsattributedstring - Swift 6 concurrency issue with `NSTextAttachmentViewProvider` - Stack Overflow](https://stackoverflow.com/questions/79278413/swift-6-concurrency-issue-with-nstextattachmentviewprovider#:~:text=Right%20now%2C%20you%20can%20work,be%20on%20the%20main%20actor)). This convinces the compiler and ensures at runtime that you're on the correct thread. It’s essentially acknowledging “this is a Swift limitation; I as the developer ensure this is safe.”
  - If a needed API absolutely cannot be made to compile under strict concurrency (and it’s not something you can change), you might keep such code in a separate module compiled with Swift 5 mode or mark it with `@available(*, unavailable, message: "Not concurrency-safe")` to avoid its use in concurrent contexts. The better approach, however, is usually to find a concurrency-safe alternative or contain the unsafeness behind a facade that the rest of your code can call safely.

- **Testing and Tools:** Leverage Xcode’s tools for concurrency. Use the Thread Sanitizer and Swift Concurrency checks (the debugger can show warnings about incorrect actor usage at runtime). Instruments in Xcode 14+ also has a “Swift Concurrency” template that helps catch threading issues and visualize tasks ([Visualize and optimize Swift concurrency - WWDC22 - Videos](https://developer.apple.com/videos/play/wwdc2022/110350/#:~:text=Visualize%20and%20optimize%20Swift%20concurrency,you%20how%20to%20use)) ([Eliminate data races using Swift Concurrency - WWDC22 - Videos](https://developer.apple.com/videos/play/wwdc2022/110351/#:~:text=Eliminate%20data%20races%20using%20Swift,approach%20to%20eliminating%20data)). During migration, turn on the Swift 6 preview mode flags in your Swift 5 project (`-Xswiftc -strict-concurrency=complete` and related upcoming feature flags) ([Migrating to Swift 6](https://blog.brandonweng.com/posts/migrating-swift-6#:~:text=In%20my%20case%2C%20I%20added,file)) so that you can see issues early and address them incrementally, rather than being swamped with errors all at once after upgrading.

## 4. Migration Challenges from Earlier Swift Versions to Swift 6

Migrating an existing codebase to Swift 6’s concurrency model can be challenging. Some of the key hurdles developers face include:

- **Resolving New Compiler Errors:** The first thing teams notice when switching to Swift 6 language mode is a wave of compiler errors where there were none. These correspond to the strict concurrency checks. Warnings such as calls to main-actor methods from non-main code, or non-Sendable types in concurrent closures, now halt the build ([How to fix this Swift 6 migration … | Apple Developer Forums](https://developer.apple.com/forums/thread/763849#:~:text=Xcode%20shows%20warnings%20that%20,How%20can%20I%20fix%20this)). Developers must methodically fix these by marking functions as `async`/`await` where needed, adding `@MainActor` or moving code to the right context, and adding `Sendable` conformances or using `[weak self]` to capture self by reference. Each error often has a clear fix, but in a large project the number of edits can be significant.

- **Refactoring Architecture:** Some design patterns that were tolerated in Swift 5 become problematic in Swift 6. Commonly, heavy use of singletons or global mutable state requires rework. One developer reported having to refactor “a ton of Singletons and global state” during Swift 6 migration ([Migrating to Swift 6](https://blog.brandonweng.com/posts/migrating-swift-6#:~:text=Unfortunately%2C%20I%20used%20a%20ton,and%20others%20became%20Global%20MainActors)). The strict isolation rules basically forced a redesign: they converted many singletons into actors or made them `@MainActor` bound, and in some cases eliminated global state entirely, because sharing mutable state freely between threads is no longer allowed without synchronization. This kind of refactoring, while time-consuming, improved the codebase by making thread access patterns explicit ([Migrating to Swift 6](https://blog.brandonweng.com/posts/migrating-swift-6#:~:text=Unfortunately%2C%20I%20used%20a%20ton,and%20others%20became%20Global%20MainActors)) ([Migrating to Swift 6](https://blog.brandonweng.com/posts/migrating-swift-6#:~:text=Key%20Takeaways)). However, it does mean migration isn’t just a find-and-replace; it can involve architectural changes.

- **Dealing with Legacy or Third-Party Code:** Not all dependencies might be Swift-6-ready. If you rely on libraries (including Apple’s own frameworks) that haven’t adopted Swift concurrency annotations, the compiler may complain about their use. For example, many Apple APIs are only annotated as `@MainActor` or `Sendable` in iOS 17+/Xcode 15+ SDKs. If you use an older API or a third-party SDK, you might get concurrency warnings. The Swift core team noted “not all of Apple's code is necessarily Swift 6 compatible” under strict checking ([How to plan a migration to Swift 6 - Donny Wals](https://www.donnywals.com/how-to-plan-a-migration-to-swift-6/#:~:text=How%20to%20plan%20a%20migration,compatible%20or%20Swift%206)). Migration guides suggest using techniques like the `@preconcurrency` import or isolating calls to such code. In practice, some teams disable strict concurrency checks for certain modules initially, then address them as the libraries update or as they find workarounds.

- **Behavior Changes and Semantic Shifts:** It’s important to ensure that fixing the compiler errors doesn’t inadvertently change the program’s behavior. For instance, converting completion-handlers to `async/await` can introduce unintended serialization. Donny Wals highlights a migration example where code performing 10 network requests concurrently (using callbacks) was naively converted to a for-loop with `await`, which then ran them one-by-one ([How to plan a migration to Swift 6 – Donny Wals](https://www.donnywals.com/how-to-plan-a-migration-to-swift-6/#:~:text=for%20page%20in%200..,)) ([How to plan a migration to Swift 6 – Donny Wals](https://www.donnywals.com/how-to-plan-a-migration-to-swift-6/#:~:text=The%20meaning%20of%20this%20code,calls%20in%20parallel%20that%20way)). The semantics changed from concurrent to sequential, potentially impacting performance and functionality. The correct fix was to use tasks or a `TaskGroup` to maintain parallelism ([How to plan a migration to Swift 6 – Donny Wals](https://www.donnywals.com/how-to-plan-a-migration-to-swift-6/#:~:text=The%20meaning%20of%20this%20code,calls%20in%20parallel%20that%20way)). Thus, migration involves understanding the *intent* of existing code and choosing the right concurrency construct to preserve or improve it. Simply appeasing the compiler is not enough; one must consider if asynchronous calls need to be parallel or can be sequential, if an actor should be reentrant or not, etc.

- **MainActor adoption in SwiftUI:** The change to the SwiftUI `View` protocol being `@MainActor` simplified some issues but can complicate migration in a different way. In Xcode 15 and earlier, developers might have added manual `@MainActor` annotations to certain views or used workarounds to handle the lack of automatic isolation. After upgrading to Xcode 16 (Swift 6), those workarounds might be redundant. Conversely, some code that was previously failing (like our earlier `increment()` example in a SwiftUI Button) now works by default since the view is main-actor isolated ([Task Isolation Inheritance and Swi… | Apple Developer Forums](https://forums.developer.apple.com/forums/thread/761150#:~:text=%40MainActor%20%40preconcurrency%20public%20protocol%20View,get%20%7D)). But a caution: making views `@MainActor` by default might surface performance problems (if views were doing heavy work that is now all on main). Migrators should review any long-running tasks in views; if a view was made main-actor implicitly and it performs a lot of computation, you may need to refactor that work out of the view to avoid blocking the UI ([Task Isolation Inheritance and Swi… | Apple Developer Forums](https://forums.developer.apple.com/forums/thread/761150#:~:text=The%20entire%20,%60View%60%20chain)). Essentially, migration may fix one class of bugs (threading issues) but reveal design issues (like doing too much on the main thread).

- **Fixing Environment and State Initializer Issues:** As seen in the EnvironmentKey example, certain patterns (like using `UIScreen.main` for a default value) must change. The solution might be as simple as providing a constant default (e.g., 0 for a height) ([Swift 6 concurrency issue with EnvironmentKey - Stack Overflow](https://stackoverflow.com/questions/79015118/swift-6-concurrency-issue-with-environmentkey#:~:text=If%20you%20are%20always%20setting,it%20to%20some%20constant%20value)) or injecting the real value at runtime via `.environment` in the app setup ([Swift 6 concurrency issue with EnvironmentKey - Stack Overflow](https://stackoverflow.com/questions/79015118/swift-6-concurrency-issue-with-environmentkey#:~:text=If%20you%20do%20need%20to,root%20of%20your%20view%20hierarchy)). SwiftUI state properties that were initialized with main-actor objects now require the containing type to be main-actor or to find a different initialization approach ([SwiftUI Views and @MainActor](https://fatbobman.com/en/posts/swiftui-views-and-mainactor/#:~:text=struct%20DemoView%3A%20View%20,)) ([SwiftUI Views and @MainActor](https://fatbobman.com/en/posts/swiftui-views-and-mainactor/#:~:text=This%20issue%20arises%20because%2C%20by,the%20aforementioned%20issue%20is%20resolved)). Migration guides (including Apple’s official ["Migrating to Swift 6"](https://www.swift.org/migration/documentation/migrationguide) document) list recipes for these scenarios. Apple suggests techniques such as using global actors, `MainActor.assumeIsolated`, or restructuring code to satisfy the new rules ([How to fix this Swift 6 migration … | Apple Developer Forums](https://developer.apple.com/forums/thread/763849#:~:text=Note%20how%20,which%20has%20two%20functions)) ([How to fix this Swift 6 migration … | Apple Developer Forums](https://developer.apple.com/forums/thread/763849#:~:text=avPlayer,self%3F.myMainActorIsolatedMethod%28%29%20%7D)). It may also be helpful to leverage new SwiftUI  macro features (like the `@Entry` property wrapper for environment values introduced in Xcode 16) to simplify code that previously required static keys ([Swift 6 concurrency issue with EnvironmentKey - Stack Overflow](https://stackoverflow.com/questions/79015118/swift-6-concurrency-issue-with-environmentkey#:~:text=static%20let%20defaultValue%3A%20CGFloat%20%3D,0)).

- **Incremental Adoption:** A recommended strategy is to enable Swift 6 concurrency checks gradually in a Swift 5 project by using compiler flags (often called *upcoming feature flags*). For example, adding `-strict-concurrency=complete` along with flags to disable actor inference and enable sendable checking will let you see where issues are, while still compiling in Swift 5 mode ([Migrating to Swift 6](https://blog.brandonweng.com/posts/migrating-swift-6#:~:text=In%20my%20case%2C%20I%20added,file)). You can then fix issues file by file. Apple’s Swift 6 migration guide emphasizes this incremental approach, allowing teams to tackle warnings one at a time and even run mixed-mode (some code with strict checking, some without) until the entire codebase is ready to flip the switch to Swift 6 mode ([Migrating to Swift 6](https://blog.brandonweng.com/posts/migrating-swift-6#:~:text=This%20is%20going%20to%20depend,not%20introduce%20any%20more%20warnings)) ([Migrating to Swift 6](https://blog.brandonweng.com/posts/migrating-swift-6#:~:text=When%20I%20got%20stuck%20or,making%20the%20suggestions%20they%20are)). This avoids a scenario where hundreds of errors appear overnight without a plan to resolve them.

## 5. Developer Experiences and Insights

Early adopters of Swift 6 concurrency have shared their experiences through blog posts and forums, providing valuable insights:

- **Significant Safety Benefits:** Developers report that the effort of migration pays off in reliability. One engineer described Swift 6’s enhanced concurrency model as a *“game-changer”* for their app: after migrating, data races and mysterious threading crashes virtually disappeared ([Migrating to Swift 6](https://blog.brandonweng.com/posts/migrating-swift-6#:~:text=The%20most%20compelling%20reason%20to,rely%20heavily%20on%20concurrent%20operations)) ([Migrating to Swift 6](https://blog.brandonweng.com/posts/migrating-swift-6#:~:text=streams%2C%20performs%20on,significantly%20improving%20the%20user%20experience)). By catching race conditions at compile time, Swift 6 saved them “countless hours of debugging” and improved user experience with more stable concurrent operations ([Migrating to Swift 6](https://blog.brandonweng.com/posts/migrating-swift-6#:~:text=In%20my%20case%2C%20this%20was,significantly%20improving%20the%20user%20experience)). This sentiment is common – teams find that once the code compiles under strict concurrency, it runs with fewer concurrency-related bugs than before. In essence, the compiler is now doing heavy lifting to guarantee thread safety that used to be the developer’s responsibility.

- **Migration is Challenging but Worthwhile:** Many developers acknowledge that migrating to Swift 6 is non-trivial. As one blog put it, the process was “a significant challenge in Swift 5… three full days of grinding” to fix concurrency issues, but *“absolutely worth it”* in the end ([Migrating to Swift 6](https://blog.brandonweng.com/posts/migrating-swift-6#:~:text=I%27m%20only%20four%20months%20into,that%20haven%27t%20been%20migrated%20yet)) ([Migrating to Swift 6](https://blog.brandonweng.com/posts/migrating-swift-6#:~:text=struggling%20with%20concurrency%20issues%2C%20I,that%20haven%27t%20been%20migrated%20yet)). Common advice is to approach it systematically: enable checks, fix or refactor step by step, and not to panic at the volume of warnings. The migration often leads to cleaner code – for example, eliminating those implicit assumptions about threads and forcing clearer separation of concerns (UI vs background work) ([Migrating to Swift 6](https://blog.brandonweng.com/posts/migrating-swift-6#:~:text=Unfortunately%2C%20I%20used%20a%20ton,and%20others%20became%20Global%20MainActors)) ([Migrating to Swift 6](https://blog.brandonweng.com/posts/migrating-swift-6#:~:text=Key%20Takeaways)). Developers also stress the importance of understanding Swift’s concurrency paradigms (actors, async/await, sendability) deeply rather than just making the compiler errors go away. Rushing the migration without learning can result in suboptimal fixes (or overuse of `@unchecked Sendable` which can reintroduce risk) ([Migrating to Swift 6](https://blog.brandonweng.com/posts/migrating-swift-6#:~:text=When%20I%20got%20stuck%20or,making%20the%20suggestions%20they%20are)).

- **Learning Curve and Team Knowledge:** Teams that have gone through this recommend educating all members about the concepts. Donny Wals notes that simply fixing code to compile isn’t enough – developers need to **reason about the intent** of code in a concurrent context ([How to plan a migration to Swift 6 – Donny Wals](https://www.donnywals.com/how-to-plan-a-migration-to-swift-6/#:~:text=The%20hardest%20part%20in%20solving,just%20making%20the%20compiler%20happy)) ([How to plan a migration to Swift 6 – Donny Wals](https://www.donnywals.com/how-to-plan-a-migration-to-swift-6/#:~:text=You%27re%20having%20to%20think%20about,to%20keep%20the%20compiler%20happy)). When teaching teams, ensuring everyone knows when to use a task group vs. a detached task, or why to mark something `@MainActor`, is crucial ([How to plan a migration to Swift 6 – Donny Wals](https://www.donnywals.com/how-to-plan-a-migration-to-swift-6/#:~:text=know%20exactly%20which%20tools%20you,be%20reasoning%20about%20your%20code)). Some companies have used workshops and shared resources to get everyone up to speed on Swift concurrency before or during the migration ([How to plan a migration to Swift 6 – Donny Wals](https://www.donnywals.com/how-to-plan-a-migration-to-swift-6/#:~:text=Ensuring%20your%20team%20has%20all,the%20knowledge%20they%20need)) ([How to plan a migration to Swift 6 – Donny Wals](https://www.donnywals.com/how-to-plan-a-migration-to-swift-6/#:~:text=So%20I%20always%20recommend%20if,trivial%20to%20pick%20up%20Swift)). The consensus is that once the mental model clicks (understanding actor isolation, etc.), writing concurrent code becomes more straightforward and one appreciates the compiler’s guidance.

- **Community Solutions and Workarounds:** The community has actively discussed Swift 6 concurrency problems and solutions. The official Swift forums and Apple Developer forums are filled with Q&A threads on specific errors. Apple’s engineers (like Quinn “The Eskimo” from DTS) have provided recipes for tricky cases – for example, how to handle callbacks on main with `assumeIsolated` ([How to fix this Swift 6 migration … | Apple Developer Forums](https://developer.apple.com/forums/thread/763849#:~:text=Note%20how%20,which%20has%20two%20functions)) ([How to fix this Swift 6 migration … | Apple Developer Forums](https://developer.apple.com/forums/thread/763849#:~:text=avPlayer,self%3F.myMainActorIsolatedMethod%28%29%20%7D)), or explaining why a `Task` inside a view might still be on the main thread ([Task Isolation Inheritance and Swi… | Apple Developer Forums](https://forums.developer.apple.com/forums/thread/761150#:~:text=So%2C%20what%E2%80%99s%20going%20on%3F%20The,on%20the%20main%20thread)). There’s also recognition of current limitations – e.g., the `NSTextAttachmentViewProvider` issue was acknowledged as a language limitation to be improved, with a forum thread tracking it ([nsattributedstring - Swift 6 concurrency issue with `NSTextAttachmentViewProvider` - Stack Overflow](https://stackoverflow.com/questions/79278413/swift-6-concurrency-issue-with-nstextattachmentviewprovider#:~:text=1)) ([nsattributedstring - Swift 6 concurrency issue with `NSTextAttachmentViewProvider` - Stack Overflow](https://stackoverflow.com/questions/79278413/swift-6-concurrency-issue-with-nstextattachmentviewprovider#:~:text=This%20is%20currently%20just%20a,on%20this%20Swift%20Forums%20thread)). Developers have shared tips like using a custom `MainActorView` protocol to tag many views as main-actor easily ([SwiftUI Views and @MainActor](https://fatbobman.com/en/posts/swiftui-views-and-mainactor/#:~:text=To%20further%20simplify%20the%20process%2C,the%20main%20thread%20execution%20environment)) ([SwiftUI Views and @MainActor](https://fatbobman.com/en/posts/swiftui-views-and-mainactor/#:~:text=Thus%2C%20any%20view%20that%20implements,execute%20on%20the%20main%20thread)), or how they restructured code to avoid concurrency conflicts. Blog posts (such as by Fatbobman ([SwiftUI Views and @MainActor](https://fatbobman.com/en/posts/swiftui-views-and-mainactor/#:~:text=An%20increasing%20number%20of%20developers,within%20SwiftUI%20views)) and others) specifically address SwiftUI scenarios, helping others avoid common mistakes in view code with `@MainActor`. In short, there is a growing body of knowledge – official docs, forums, and community blogs – that new Swift 6 adopters can leverage to make their journey smoother.

- **Performance Considerations:** Some developers caution that after making everything compile in Swift 6, one should re-evaluate performance. Because strict concurrency might push more work onto the main thread (for safety) or sequentialize certain tasks that were previously concurrent, it’s wise to test and optimize where needed. The Swift concurrency model still allows high performance, but it might require using features like task groups or actors correctly. One Reddit discussion noted hopes that Apple will continue to refine performance and reduce any overhead from the safety checks ([Strict Concurrency and UIKit - swift - Reddit](https://www.reddit.com/r/swift/comments/1bsiimc/strict_concurrency_and_uikit/#:~:text=Strict%20Concurrency%20and%20UIKit%20,hoping%20that%20Apple%20will)). Apple’s WWDC talks (e.g., “Visualize and optimize Swift concurrency”) show how to use Instruments to detect issues like too many tasks on the main actor ([Visualize and optimize Swift concurrency - WWDC22 - Videos](https://developer.apple.com/videos/play/wwdc2022/110350/#:~:text=Visualize%20and%20optimize%20Swift%20concurrency,you%20how%20to%20use)) ([Visualize and optimize Swift concurrency - WWDC22 - Videos](https://developer.apple.com/videos/play/wwdc2022/110350/#:~:text=Learn%20how%20you%20can%20optimize,you%20how%20to%20use)). Developers have found that sometimes simply restructuring an algorithm to use concurrency properly (e.g., concurrent map or filtering using tasks) can more than make up for any overhead introduced by the safety checks.

In conclusion, **Swift 6’s concurrency updates** mark a major step towards safer and more maintainable async code. The introduction of pervasive `@MainActor` isolation for UI components and stricter enforcement of Sendable and actor rules help catch bugs at compile time that would be disastrous at runtime. While this evolution brings migration pain and forces developers to unlearn some old habits, the consensus is that it leads to cleaner separation of UI and background logic and more robust applications. By understanding the new rules, adjusting code accordingly, and following best practices (isolate UI to main thread, use actors for shared state, leverage async/await wisely), developers can fully harness Swift’s modern concurrency with fewer pitfalls. Swift 6 essentially nudges developers to do the “right thing” for thread safety, and those who have made the jump report more confidence in their concurrent code. The journey involves careful refactoring and learning, but it positions Swift apps to be responsive, correct, and future-proof in a world that's increasingly concurrent.

**Sources:**

- Apple Developer Documentation and Forums on Swift Concurrency and `@MainActor` (WWDC notes, Swift forums)  
- Fatbobman Blog – *“SwiftUI Views and @MainActor”* (Mar & Jun 2024) ([SwiftUI Views and @MainActor](https://fatbobman.com/en/posts/swiftui-views-and-mainactor/#:~:text=An%20increasing%20number%20of%20developers,within%20SwiftUI%20views)) ([SwiftUI Views and @MainActor](https://fatbobman.com/en/posts/swiftui-views-and-mainactor/#:~:text=,protocol%20in%20the%20Xcode%2016)) ([SwiftUI Views and @MainActor](https://fatbobman.com/en/posts/swiftui-views-and-mainactor/#:~:text=struct%20DemoView%3A%20View%20,)) ([SwiftUI Views and @MainActor](https://fatbobman.com/en/posts/swiftui-views-and-mainactor/#:~:text=This%20issue%20arises%20because%2C%20by,the%20aforementioned%20issue%20is%20resolved))  
- Apple DTS (Quinn) – Developer Forums post on *“Task Isolation Inheritance and SwiftUI”* (Aug 2024) ([Task Isolation Inheritance and Swi… | Apple Developer Forums](https://forums.developer.apple.com/forums/thread/761150#:~:text=Folks%20look%20at%20this%20code,to%20prove%20this%20to%20yourself)) ([Task Isolation Inheritance and Swi… | Apple Developer Forums](https://forums.developer.apple.com/forums/thread/761150#:~:text=So%2C%20what%E2%80%99s%20going%20on%3F%20The,on%20the%20main%20thread)) ([Task Isolation Inheritance and Swi… | Apple Developer Forums](https://forums.developer.apple.com/forums/thread/761150#:~:text=%40MainActor%20%40preconcurrency%20public%20protocol%20View,get%20%7D))  
- Swift Forums – *Progress toward the Swift 6 language mode* (Nov 2023, Holly Borla) ([Progress toward the Swift 6 language mode - Announcements - Swift Forums](https://forums.swift.org/t/progress-toward-the-swift-6-language-mode/68315#:~:text=%2A%20SE,values%20through%20isolated%20value%20regions)) ([Progress toward the Swift 6 language mode - Announcements - Swift Forums](https://forums.swift.org/t/progress-toward-the-swift-6-language-mode/68315#:~:text=Together%2C%20these%20changes%20fill%20the,and%20can%20be%20explored%20independently)); Discussion on global actor inference ([Change to Global Actor Inference in Swift 6 Language Mode? - Using Swift - Swift Forums](https://forums.swift.org/t/change-to-global-actor-inference-in-swift-6-language-mode/76086#:~:text=Long%20story%20short%2C%20Swift%206,such%20cases%20about%20isolation%20mismatch))  
- Stack Overflow – Swift 6 concurrency Q&A (EnvironmentKey issue ([Swift 6 concurrency issue with EnvironmentKey - Stack Overflow](https://stackoverflow.com/questions/79015118/swift-6-concurrency-issue-with-environmentkey#:~:text=Now%20there%20seems%20to%20be,to%20uphold%20protocol%20conformance)) ([Swift 6 concurrency issue with EnvironmentKey - Stack Overflow](https://stackoverflow.com/questions/79015118/swift-6-concurrency-issue-with-environmentkey#:~:text=If%20you%20are%20always%20setting,it%20to%20some%20constant%20value)) and NSTextAttachmentViewProvider issue ([nsattributedstring - Swift 6 concurrency issue with `NSTextAttachmentViewProvider` - Stack Overflow](https://stackoverflow.com/questions/79278413/swift-6-concurrency-issue-with-nstextattachmentviewprovider#:~:text=This%20will%20not%20compile%20with,the%20following%20error)) ([nsattributedstring - Swift 6 concurrency issue with `NSTextAttachmentViewProvider` - Stack Overflow](https://stackoverflow.com/questions/79278413/swift-6-concurrency-issue-with-nstextattachmentviewprovider#:~:text=This%20is%20currently%20just%20a,on%20this%20Swift%20Forums%20thread)))  
- Donny Wals – *“How to plan a migration to Swift 6”* (2024) ([How to plan a migration to Swift 6 – Donny Wals](https://www.donnywals.com/how-to-plan-a-migration-to-swift-6/#:~:text=The%20hardest%20part%20in%20solving,just%20making%20the%20compiler%20happy)) ([How to plan a migration to Swift 6 – Donny Wals](https://www.donnywals.com/how-to-plan-a-migration-to-swift-6/#:~:text=The%20meaning%20of%20this%20code,calls%20in%20parallel%20that%20way))  
- Brandon Weng – *“Migrating to Swift 6”* (Mar 2025) ([Migrating to Swift 6](https://blog.brandonweng.com/posts/migrating-swift-6#:~:text=Unfortunately%2C%20I%20used%20a%20ton,and%20others%20became%20Global%20MainActors)) ([Migrating to Swift 6](https://blog.brandonweng.com/posts/migrating-swift-6#:~:text=away%20from%20Singletons%20entirely,and%20others%20became%20Global%20MainActors)) ([Migrating to Swift 6](https://blog.brandonweng.com/posts/migrating-swift-6#:~:text=When%20I%20got%20stuck%20or,making%20the%20suggestions%20they%20are))  
- Apple Developer Forums – *“How to fix this Swift 6 migration issue?”* (DTS response, Sep 2024) ([How to fix this Swift 6 migration … | Apple Developer Forums](https://developer.apple.com/forums/thread/763849#:~:text=Xcode%20shows%20warnings%20that%20,How%20can%20I%20fix%20this)) ([How to fix this Swift 6 migration … | Apple Developer Forums](https://developer.apple.com/forums/thread/763849#:~:text=Note%20how%20,which%20has%20two%20functions)) ([How to fix this Swift 6 migration … | Apple Developer Forums](https://developer.apple.com/forums/thread/763849#:~:text=avPlayer,self%3F.myMainActorIsolatedMethod%28%29%20%7D))  

